#!/usr/bin/python

import argparse
import csv
import os
import sys
from datetime import datetime

parser = argparse.ArgumentParser(
    description='Given a list of valid users with their hashed-phone numbers, extracts '
                'their CDRs from the CDR input files, converts the CDR to a format '
                'compatible with Bandicoot. For example it replaces each antenna '
                'location with an id which is obtained from the third input (the mapping '
                'from antenna location to id. As output, it generates several '
                'directories each containing several files, with each file containing '
                'the CDRs for a single user. Each directory will contain at most 10,000 '
                'files.')
parser.add_argument('valid_users_input_file')
parser.add_argument('-vu', '--valid_users_in_cdrs', dest='valid_users_in_cdrs',
                    default=False, action='store_true',
                    help='If set, instead of extracting valid users that also appear '
                    'in CDRs, they are directly read from the valid_users_input_file. In '
                    'other words this file is assumed to have valid users which have '
                    'appeared in CDRs (probably generated by this same script). This '
                    'allows launching multiple versions of this script each with '
                    'different list of valid users.')
parser.add_argument('cdrs_input_dir')
parser.add_argument('antennas_input_file')
parser.add_argument('cdrs_output_dir')
parser.add_argument('-uo', '--valid_users_output', dest='valid_users_output',
                    help='If specified, the valid users that also appear in CDRs is '
                    'written to this file and the program exits. This is useful, if you '
                    'want to split the processing of all CDRs between multiple runs of '
                    'this script based on different customers.')
args = parser.parse_args()

def get_bandicoot_cdr(raw_cdr, input_filename, antennas):
  # the list should contain the following items in order:
  # interaction,direction,correspondent_id,datetime,call_duration,antenna_id
  interaction = 'call' if 'call' in input_filename else 'text'
  direction = 'out' if raw_cdr[4] == 'SALIENTE' else 'in'
  if interaction == 'call':
    correspondent_id = raw_cdr[3]
  elif direction == 'out':  # text outgoing
    correspondent_id = raw_cdr[2]
  else:                     # text incoming
    correspondent_id = raw_cdr[3]

  if interaction == 'call':
    raw_datetime = raw_cdr[10]
  else:
    raw_datetime = raw_cdr[9]
  raw_datetime = raw_datetime.replace('p.m.', 'PM')
  raw_datetime = raw_datetime.replace('a.m.', 'AM')
  bp_datetime_obj = datetime.strptime(raw_datetime, '%d/%m/%Y %I:%M:%S %p')
  bp_datetime = bp_datetime_obj.strftime('%Y-%m-%d %H:%M:%S')

  # Call duration only valid for call interaction
  call_duration = ''
  if interaction == 'call':
    call_duration = raw_cdr[5]

  # antenna info only available for call interaction
  antenna_id = ''
  if interaction == 'call':
    latitude = raw_cdr[7]
    longitude = raw_cdr[8]
    if latitude and longitude:
      key = (latitude, longitude)
      if key in antennas:
        antenna_id = antennas[key]
      else:
        sys.exit('Error: Missing antenna info: ' + str(key))

  return (interaction, direction, correspondent_id,
          bp_datetime, call_duration, antenna_id)

# extracts those users that are valid and also appear in cdrs
def get_valid_users_in_cdrs(valid_users_input_file, cdrs_input_dir):
  line_num = 0;
  # First get all valid users whether or not they are in cdrs
  valid_users = set()
  with open(valid_users_input_file, 'r') as valid_users_file:
    valid_users_reader = csv.reader(valid_users_file, delimiter ='|')
    for row in valid_users_reader:
      row = [x.strip() for x in row]
      phone_hash = row[0]
      valid_users.add(phone_hash)

  # Now go through all cdrs and extract users that are valid
  valid_users_in_cdrs = set()
  for input_filename in os.listdir(cdrs_input_dir):
    cdrs_input_file = open(os.path.join(cdrs_input_dir, input_filename), 'r')
    cdrs_input_reader = csv.reader(cdrs_input_file, delimiter = '|')
    for row in cdrs_input_reader:
      row = [x.strip() for x in row]
      line_num += 1
      if line_num % 1000000 == 0:
        print('Read ' + str(line_num) + ' lines.')

      if len(row) < 4:
        sys.exit('Bad CDR row: ' + str(row))
      # phone hash of customer is in second fields of both text and call records
      user = row[1]
      if user in valid_users and user not in valid_users_in_cdrs:
        valid_users_in_cdrs.add(user)

  return list(valid_users_in_cdrs)


def main():
  # If valid users already specified, use it otherwise need to extract it.
  if args.valid_users_in_cdrs:
    valid_users_input_file = open(args.valid_users_input_file, 'r')
    valid_users_in_cdrs = [valid_user.strip() for valid_user in valid_users_input_file]
    valid_users_input_file.close()
  else:
    valid_users_in_cdrs = get_valid_users_in_cdrs(args.valid_users_input_file,
                                                  args.cdrs_input_dir)
  if len(valid_users_in_cdrs) == 0:
    sys.exit('There were no valid users!')

  if args.valid_users_output:
    valid_users_output_file = open(args.valid_users_output, 'w')
    for valid_user in valid_users_in_cdrs:
      valid_users_output_file.write("%s\n" % valid_user)
    return

  # create a dictionary from (lat,lng) to antenna-id
  antennas = dict()
  with open(args.antennas_input_file, 'r') as f:
    antenna_input_reader = csv.reader(f, delimiter =',')
    # Skip header
    next(antenna_input_reader, None)
    for row in antenna_input_reader:
      antenna_id = row[0]
      latitude = row[1]
      longitude = row[2]
      antennas[(latitude, longitude)] = antenna_id


  num_users_completed = 0
  max_num_users_per_dir = 50000
  while (num_users_completed < len(valid_users_in_cdrs)):
    # create output dir for the next 1000 users
    num_users_in_dir = min(max_num_users_per_dir,
                           len(valid_users_in_cdrs) - num_users_completed)
    output_dir = os.path.join(args.cdrs_output_dir,
                              str(num_users_completed) + '-' +
                              str(num_users_completed + num_users_in_dir - 1))
    os.makedirs(output_dir)
    
    # add cdrs for each user to a set, since we could have multiple identical rows
    user_cdr_sets = dict()
    for i in range(0, num_users_in_dir):
      user = valid_users_in_cdrs[num_users_completed + i]
      user_cdr_sets[user] = set()

   
    # Now loop through cdr files and fetch cdrs for these users
    line_num = 0;
    for input_filename in os.listdir(args.cdrs_input_dir):
      cdrs_input_file = open(os.path.join(args.cdrs_input_dir, input_filename), 'r')
      cdrs_input_reader = csv.reader(cdrs_input_file, delimiter = '|')
      for row in cdrs_input_reader:
        line_num += 1
        if line_num % 10000000 == 0:
          print('Read ' + str(line_num) + ' lines.')

        row = [x.strip() for x in row]
        if len(row) < 4:
          sys.exit('Bad CDR row: ' + str(row))
        # phone hash of customer is in second fields of both text and call records
        user = row[1]
        if user in user_cdr_sets:
          cdr = get_bandicoot_cdr(row, input_filename, antennas)
          # Store bandicoot compatible cdr and add it to set, so that duplicates won't be
          # added
          user_cdr_sets[user].add(cdr)
     

      cdrs_input_file.close()
    
    # write the cdrs
    for i in range(0, num_users_in_dir):
      user = valid_users_in_cdrs[num_users_completed + i]
      cdrs_output_file = open(os.path.join(output_dir, user), 'w')
      cdrs_output_writer = csv.writer(cdrs_output_file, delimiter = ',')
      cdrs_output_writer.writerow(
          ["interaction", "direction", "correspondent_id", "datetime",
           "call_duration", "antenna_id"])
      for cdr in user_cdr_sets[user]:
        cdrs_output_writer.writerow(cdr)
      cdrs_output_file.close()


    # Update: finished these users
    num_users_completed += num_users_in_dir
    print('Completed ' + str(num_users_completed) + ' users.')


if __name__ == "__main__":
  main()
